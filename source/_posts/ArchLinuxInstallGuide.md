---
title: Arch Linux 安装初级指南
date: 2022-08-03 00:00:00
categories:
  - 实景事件模拟
description: 它并不困难， 只是有点特别。<br/>这是属于你的世界，我很荣幸为你敲开它的大门。
---

## 欢迎

既然你已经来到这里，说明你想要获得一份纯净的 GNU/Linux，并且在万千选择中，挑中了你中意的那一个。这就是 Arch Linux，一个「注重简洁的发行版」。

### 我们从一个问题开始

> Arch Linux 这么难用，为什么还要用它？

Arch Linux 难用吗？**难，但是也不难**。所有说 Arch 难用的人，绝对没有亲自用过 Arch。尽管安装过程费时费力，但是你的付出将得到足够的回报：完全的自由，完全的定制。

当然，如果按易用性来看，Debian，LinuxMint，CentOS，Ubuntu 都更好用，几个按钮就能解决的问题，多简单。

可是似乎有一点不对……

- 我为小巧精悍而来，我如何接受 Flatpak？

- 我为软件自由而来，我如何同意 SnapCraft？

- 我为安全可控而来，我如何理解自动更新？

- 我为隐私秘密而来，我如何认可数据收集？

如果所谓的易用性要以这些更为重要的东西为代价，那么这样得来的「好用」到底有什么价值？！

……

几乎所有的 GNU/Linux 发行版都或多或少包含着「预装」和「产品」的成分，而 Arch Linux 是为数不多拒绝这样做的发行版之一。

我选择 Arch Linux，不是因为其看上去专业，也并非因为它更加完美，事实上，它比大多数发行版都要简单，甚至是简朴。

**而我看重的，正是这份简朴背后的纯粹。我们相信你也是如此。**

### 开始之前

欢迎来到 Arch Linux 的世界！你一定已经对 Arch 有所耳闻，作为被称为「邪」的 Linux 发行版，Arch 和其它的发行版很不一样，它没有好看的 GUI，没有方便的安装程序，但这并不能掩饰它独特的魅力：

- 滚动式发行，一次安装即可。

- 你能获得一套真正「纯净」的 GNU/Linux 操作系统。

- 运行很快。

- 无需配置即免疫大多数病毒。

- 几乎不需要清理垃圾。

- 拥有世界上最大的软件库 AUR。

- 非常好玩且有趣！（真的是这样！）

- 由于只支持一种架构，反而避免了很多问题。

- 拥有世界上最好的文档之一：[ArchWiki](https://wiki.archlinux.org/)。

- 会真正显得你很酷。

……诸如此类。

为了给你一点信心，我们用两张图片来展示一下。

**你以为的 Arch Linux：**

![.](https://img.gejiba.com/images/e78ef6d94d3380c3d008e57b99c9978c.png)

*TTY On Arch ISO*

*图片来自网络。*

**事实上的 Arch Linux：**

![.](https://img.gejiba.com/images/5de0036a31d12fd8859c393b7728ed1e.png)

*Arch Linux, GNOME 42 With Orchis*

*图片来自网络。*

### 注意事项

在你能够开始你的旅途前，我们有一些需要说明的内容：

- 本指南**不是面向新手的**。
  
  - Arch Linux 本身也不是面向新手的。
  
  - 你需要计算机基础知识，包括但不限于终端的基础概念和使用方法。你还得知道分区、UEFI、引导、BIOS 设置之类的是什么意思。
  
  - 你需要对 GNU/Linux 有最基本的了解，至少要知道有显示管理器，桌面环境这些概念（弄不清楚也没关系，但要知道有这么个东西）。
  
  - 需要不错的英语，或者不错的翻译姬（例如 [Google 翻译](https://translate.google.com) 以及它的 [国内版](https://translate.google.cn)），因为你会需要 ArchWiki 的帮助，而有些条目是没有翻译的。
  
  从头开始讲解以上内容会消耗大量的篇幅，在本站的其它地方你可以学习到上述内容的一部分。

- 请合理使用本指南。
  
  - 本指南所述的方法不是唯一的安装方法，也并不一定适用所有机器，**请不要照抄命令**。对你机器造成的损害，我们爱莫能助。
  
  - 本指南所述介绍内容不是专业知识，出于便于理解的目的或表述的的需要，有些可能也并不准确。如有疑问，请参考权威资料获得更准确的解释。
  
  - 确保你已经获得计算机的使用权限，**不要在你朋友的电脑上做这些**（除非他们也很感兴趣）！当然，也不要在任何不属于你的电脑上这样做。
  
  - 确保你没有什么紧急任务需要使用电脑。安装过程耗时较长，且一旦开始就不能中断。

- 保持心态稳定。
  
  - 在自己组装系统的过程中可能遇到大量的困难，而且其中很多似乎没有解决方法。
  
  - 要成功地驱动所有的部件需要投入足够的努力。
  
  - 无论如何，**不要放弃**，所有你经过的困难都会转化为你的经验，而每个问题通常都有解决方法的。

### 有关双系统的建议

首先要说明的一点是，我们建议**一台计算机只安装一套操作系统**。原因主要有：

- 兼容性问题。例如 Microsoft 要求必须启用安全启动，而 Arch Linux 默认并不支持。如果不启用，Windows 11 的部分功能将无法使用，如果要启用，就需要对 Arch Linux 进行相当麻烦的配置。

- 使用习惯问题。

- `dir` 比 `ls` 多一个字母。

- 配置的时间成本远高于再买一台计算机的成本。

- 当你会合理使用 VirtualBox 之类的软件后，你会发现一个硬盘上的 Windows 很多余。

……等等。

这篇文章并不是讲如何摆脱 Windows 依赖的，所以不多提及，你可以在本站的其它文章中找到一些。

当然，更多 Windows 用户逐渐开始了解 GNU/Linux 和自由软件毕竟是件好事，如果我们不在这里提供安装方法，他们（或许还有你）可能就会放弃本可以获得的自由。基于这一点，本指南中也增补了双系统安装的一些说明。

如果你的另一个系统根本不是 Windows，那就不会有这些顾虑，你可以按照单独安装的步骤进行安装。不过如果是 Hackintosh，小心不要更改硬件或者破坏启动区。

### 约定

本指南对一些文字有特殊的表示方法，我们在此先行约定。

- 占位符 `<>`
  
  当你注意到这样的文字时：
  
  ```bash
  echo <YourName>
  ```
  
  你应当知道需要替换 `<YourName>` 为合适的值。注意，不是替换 `YourName`，而是 `<YourName>`。
  
  举个例子，假设你的名字是 `Annie`，那么：
  
  - 这样是正确的：`echo Annie`，而
  
  - 这样是错误的：~~`echo <Annie>`~~（没有替换 `<>`）
  
  - 这样是极其错误的：~~`echo <YourName>`~~（直接照抄）
  
  你还需要知道我们所说的东西的英文。例如，如果我们提到「选择的设备是 XXX」，你应该知道我们要替换的东西是 `<Device>`（而不是 `<Snake>` 或者 `<Monkey>` 之类的）。

- 组合键
  
  我们使用 `K1 + K2` 来表示组合键，例如 `Ctrl + C`、`F12` 以及 `Shift + Alt + 5`。按数字键时，请确保按的是主键盘上的键（1~9 和 0 是排成一排的）。

## 目标与材料

### 目标

虽然服务器使用 Arch Linux（以后简称 Arch）的例子并不少，但我们的目标是桌面操作系统，因此我们可以略微降低对性能的需求，转而寻求更好的体验，同时可以使用并不那么稳定的新技术。

本指南会将这台 Arch 配置到「出厂」状态，不带任何个性化但至少能看得过去，并且能够完成后续的优化步骤。

### 材料

下述的是安装所需的设备。

- 一台计算机，Arch 将安装在其上，它应当具有以下特性：
  
  - UEFI 引导启动。
    
    如果你希望安装双系统，原先的操作系统也应当由 UEFI 引导。
    
    Windows 11 及之后的版本不再支持 Legacy BIOS，所以以后 Legacy BIOS 会很快被淘汰。截至本文写作时，已经有相当多的机型不再支持 Legacy BIOS。
  
  - 至少 2 GiB 的 RAM，但建议有 4 GiB 以上。
    
    尽管 Arch 的运行只需极少的内存，但内存越大，缓存/缓冲运行得就越好，系统会越快。
  
  - 至少 25 GiB 的磁盘**未分配空间**，但建议有 50 GiB 以上。
    
    建议使用 SSD，会拥有更好的表现。
    
    请通过压缩或删除分区等方法来腾出这些空间，而不只是删除文件。
    
    确保这些空间是连续的，否则可能会引发极大的麻烦，如果你坚持，你需要在后面的分区部分自己处理这些问题。
    
    如果只安装 Arch，那么稍后可以在安装过程中直接清除磁盘，无需此步骤。
  
  - 较新的 x86 处理器，使用 Intel 或 AMD 皆可。
    
    若要使用其它的处理器，请确保当出现故障时你可以获得技术支持。
    
    Arch 有 ARM 移植版，但不建议使用。
  
  - 较新的图形卡，老的图形卡提供的硬件加速较差。
  
  - 网络连接，可以使用无线网络，但有线网络更好。
    
    不要求是「流畅的」，因为 Arch 提供了足够多的镜像。
  
  - 已接通电源，或者至少足够几个小时的电量。
    
    操作系统安装完成前，电源管理系统不可用，电量消耗可能会变高。
  
  - 使用的是标准键盘布局（PC 键盘），对于其它键盘布局，请至 ArchWiki 寻找配置方法。
  
  - 如果要安装双系统（另一个是 Windows），请关闭 BitLocker。
    
    若不这样做，你将需要 `dislocker` 来启动 Windows（需要特殊的配置）。

- 另一台计算机（是的！），这用来浏览资料和处理一些应急情况：
  
  - 最好是另一台 Arch，但这种情况不常见。
  
  - 其次是另一台 GNU/Linux，有些软件包是可以直接复制的，它们也更容易解决安装时遇到的问题。
  
  - 网络连接，依然不需要是「流畅的」，因为 ArchWiki 在全球的速度都很快。
  
  - 如果没有计算机，请试着借一台，对配置并没有要求，但**不要使用移动设备**（它们不能完成诸如创建启动 USB 之类的操作）。

- 至少 1 GiB 的移动存储设备，但是建议至少 4 GiB，这会给你更多的选择（稍后会说到）。
  
  最好使用通用串行总线设备（USB），例如 U 盘或者移动硬盘，不要用一些奇怪的存储设备，否则你可能会遇到大麻烦。（我知道没人用光量子存储仪或者软盘，这里主要指的是有一些智能功能的存储设备）
  
  不建议通过硬盘直接安装，虽然这的确可以，但是 USB 会方便得多。
  
  Arch 对于 USB 的速度要求并不高，因为安装过程实质上是下载而非复制。
  
  设备中所有数据都将丢失，故应先备份。

- 如果目标计算机**只有**特殊的输入装置（触摸屏，触摸板），则需要备用的鼠标（和键盘）。
  
  Arch 支持绝大多数的触摸板（希望你的也是如此），但如果不能，你会需要一个临时的鼠标。
  
  确保它们是有线的，无线可能存在驱动问题。

## 安装过程

下面要正式开始动手安装了。为防止你无意中做出些不该做的事，请仔细阅读以下内容。

### 操作须知

- 确保你充分理解指南的内容，并且知晓命令每个部分的作用。当你发现 无法读懂指南的内容时，请去补充一下基础知识。

- 准确地键入命令，一个操作失误就可能摧毁整套系统。

- 不要钻牛角尖或者照搬指南，要阅读系统给出的提示。尤其是如果系统显示 `Run command blahblah to do this` 之类的信息，你不应当忽略它。

- 善用搜索引擎查找，遇事不决先 [Google](https://google.com/ncr)。（不要以无法访问作为理由，搜索引擎还有很多）

- 当遇到意外时，除了使用搜索引擎，还要参考 [ArchWiki](https://wiki.archlinux.org/)。**无论如何都不要慌张**，先停止操作，然后想想哪里出了问题。记住：只要你还能控制系统，你就有挽回的机会。

- 可以到各种社区提问，但是要记得遵守社区规则。本页面的最下方也有评论区，可以在那里寻求帮助。

- 不要一边做安装系统这种事，一边听音乐或者玩游戏。否则当你迷失在指南中时，你会有很强的挫败感。

<div style="font-size:2.5rem;text-align:center;width:100%;">数据无价 谨慎操作</div>

### 下载和验证镜像

一切的一切，都要从这个 ISO 文件说起。

你已经知道，空的磁盘不可能自己运行起来，必须要插入启动盘来启动。实际上启动盘也就是一个迷你版操作系统，Arch 也不例外。唯一比较特别的是，大多数安装程序都是从自己当中复制文件到磁盘，而 Arch 却不是，它是下载软件包并安装到指定的磁盘上。

所有 GNU/Linux 操作系统的安装环境都可称作 LiveCD，后面我们还会见到这个名字。

无论如何，现在我们需要 Arch 的安装程序。你可以从 Arch 官方的 [下载](https://archlinux.org/download/) 页面获得它的下载链接。

Arch 提供了 BT 和 HTTP 两种方式（NetBoot 基本上不能用），至于使用哪一个完全是个人喜好的问题。BT 种子在页面最上面，而 HTTP 下载在比较下面的位置，并且提供了一堆镜像。

你需要下载的文件应当是 `archlinux-x86_64.iso`，中间可能会多出一个日期，但不会有多余的前后缀。把下载的文件重命名为这个名字，以便后面的命令处理。

---

获得镜像后请**务必进行完整性校验**，这是操作系统级的东西，不能容许哪怕一点出错。

```bash
# GNU/Linux
sha1sum archlinux-x86_64.iso
md5sum archlinux-x86_64.iso
# Windows
certutil -hashfile archlinux-x86_64.iso SHA1
certutil -hashfile archlinux-x86_64.iso MD5
```

如果不会使用终端，请试着学习一下，这并不困难。你不需要记住那些命令，只需要知道如何照着指南键入它们。你也可以使用一些具有图形界面的工具完成校验。

确保输出的结果与 Arch 官网（一定要是官网啊）上的完全一致（在 HTTP 镜像列表之前，请仔细找一下）。使用两种校验方式，只是以防万一。

如果校验结果不一致，尝试重新下载，如果文件看上去依然有问题，可换一个镜像，并将错误的镜像报告给 Arch 的维护者，以便他们排查问题。

### 制作可启动介质

#### GNU/Linux

把 USB 插入电脑，执行：

```bash
sudo fdisk -l
sudo dd if=archlinux-x86_64.iso of=/dev/<YourUSBDevice>
sync
```

`fdisk` 的目的是找出你的 USB 对应的标识，通常是 `/dev/sdb` 或者 `/dev/sdc`（可以根据容量判断）。**请在确认这是你的 USB 之后再执行写入**，写入错误的磁盘会造成数据损毁。

写入完成后，拔出 USB 插入目标计算机。

#### Windows

在 Windows 上，你可以使用 [Etcher](https://www.balena.io/etcher/) 完成这个过程，[Rufus](https://rufus.ie) 也可以，但**不可以使用 UltraISO**，可能导致启动错误。

如果程序询问你引导和分区表类型，记得选择 UEFI 引导和 GPT 格式分区表。如果还询问你写入模式，选择 DD 模式。

写入后 USB 将从系统中消失，但我们确信我们已经成功写入了镜像，这是正常的（Windows 还不能识别这种结构）。确认写入完成后，就可以拔出 USB 并插入目标计算机了。

### 启动设置

关闭你的目标机器（确保是充分的关闭，不是休眠或者挂起之类的），稍等片刻后启动，并设法进入 UEFI 设置：

- 对于大多数笔记本电脑，按住或连续按下 `Esc` 按钮，并选择类似 `UEFI/BIOS Settings` 或者 `UEFI Setup` 的选项（如果有）。

- 对于大多数台式机，按住或连续按下 `Del` 按钮或 `F8` 按钮，如果不行，再试试 `Enter` 按钮，直到有办法进入 UEFI 设置。或者，如果知道主板型号，可以查询如何进入其 UEFI 设置。

> 尽管这个程序的正确名称应该是 UEFI 选项，但一些地方并不区分它和 BIOS，所以查找资料时，请也试试 BIOS 这个名字。

---

对 UEFI 选项做如下调整：（标注「必须」的是一定要完成的，其它是可选的）

- 关闭快速启动（Fast Boot）和**安全启动**（Secure Boot），后者尤其重要。（必须）
  
  *如果你使用了诸如 Windows Hello 的功能，请务必先完成安装，进行安全启动配置，并且能够正常启动 Arch 之后，重新打开安全启动，再启动 Windows。否则，你可能会吃苦头。*

- 如果进行过超频，现在暂时将处理器电压和内存频率等调回原来的数值，以免影响后续步骤。

- 启用 UEFI 引导，并将其设置为默认或优先。（必须）

- 关闭 CSM 支持模块。
  
  *启用 CSM 当然也可以正常启动，然而 Linux 内核很容易被错误的模式加载，解决这个问题的根本方法就是彻底禁用 CSM。*

- 将 USB 设备设置为第一启动项。（必须）

- 校准时间。

保存设置并重启，随后计算机会从 USB 启动。

### 接入网络

Arch LiveCD 启动后会弹出一个菜单供你选择（启动哪一个），应当选择有 `archiso` 或者 `Arch Linux Install` 字样的（通常在菜单第一项），使用上下键选定，按回车确认。

要经过几秒的加载（较慢的 USB 或处理器会需要十几秒），你才能看见 Arch LiveCD 环境的终端：

```
root@archiso ~ #
```

要做的第一件事情是确认终端可以正常运行，键入以下内容并回车：

```bash
whoami
```

应当输出 `root`。

> 如果你从没使用过 GNU/Linux 终端，你可能不习惯，这里没有鼠标，也没有好看的图像，只有苍白的提示符，所有的操作需要键盘完成。不过事实上终端是很人性化的，你只需要正确输入命令。请坚持一下，我们最后的结果可不会是这样！

---

现在，如果你的设备可以连接有线网络， 那么将电缆插入网口，网络连接即自动完成。

如果没有办法使用有线连接，运行：

```bash
rfkill unblock all
iwctl
```

你将会进入无线连接控制面板，这里同样没有好看的图像，只有一个提示符等待你的输入，但我们相信它完全可以满足我们的要求。现在输入：

```bash
device list
```

找到你的无线设备，通常应当包含 `wlan` 字样（而且通常是 `wlan0`），记下它的名字。

*如果你好奇，那么我可以告诉你 `lo` 表示本机（本地环回接口），`eth`、`ens`、`eno`、`enp` 是不同类型的以太网卡（通常是有线）。*

如果找到了不止一个无线网卡，请在下一步中都试试。

---

现在搜索网络：

```bash
station <Adaptor> get-networks
```

将 `<Adaptor>` 替换成网卡的名字，例如 `wlan0`。请确保输入的命令正确。如果你输入了不正确的命令，计算机会显示错误消息以示嘲讽。

输出中会出现网卡所发现的周边网络，选择你认为合适的一个，记下名字，然后执行：

```bash
station <Adaptor> connect <NetworkSSID>
```

类似的，把 `<NetworkSSID>` 替换为网络名即可。

遗憾的是，`iwctl` 无法显示或使用非 ASCII 字符的 WLAN SSID（网络名）。如果你在使用个人热点，这可能是一个需要考虑的问题。

*这并不是 `iwctl` 本身的缺陷，而是因为你现在的环境下还没有其它语言的输入法，也没有其它语言的字体及显示支持。*

`iwctl` 可能会要求你提供密码，密码没有回显，确定输入正确后回车即可。

连接完毕后返回 Arch 终端：

```bash
exit
```

---

测试连接是否正常：

```bash
ping archlinux.org
```

希望你能得到 `64 bytes from xxx` 这样的输出，那么你的网络连接完全正常。

如果看到 `Timeout`，请尝试 `ping` 另一个主机（例如 `ping 1.2.4.8`），如果依然超时，请检查一下路由器和网关，或者试着换一个网络。

*有些主机无法进行 Ping 检测，这是正常的，因为 Ping 也可以作为攻击手段，部分主机为防御攻击而禁止了 Ping。*

如果连接通畅，按 `Ctrl + C` 组合键中断 `ping` 进程，键入：

```bash
clear
```

以将屏幕清空。此后我们不会单独执行这条命令，但你可以在认为屏幕太乱的时候执行它。

### 调整时间

执行：

```bash
hwclock --systohc --utc
timedatectl set-ntp true
```

它们的执行需要几秒钟（联网对时），完成后运行：

```bash
timedatectl status
```

确保输出时间是正确的。

*如果时间相差几个小时也是没问题的，因为这是 UTC 时间，要考虑时区偏移的问题。*

### 分区

检查计算机上的磁盘：

```bash
fdisk -l
```

输出像是：

```
Disk /dev/sdb: 415.411 GiB, ...
```

而且可能不止一个。

---

如果上面的输出太乱，你也可以选择使用：

```bash
lsblk
```

它的输出更简单：

```
sdb                     disk
|-- sdb1    888.88 G    part
```

`disk` 表示磁盘，`part` 表示磁盘下的分区。

---

你需要选择正确的用于安装的**磁盘**（不是分区），可以通过看容量来辨别。

记住 `Disk` 后面的设备标识（`fdisk`）或者 `disk` 对应的磁盘（`lsblk`）。**不要看走眼**。如果在安装多个操作系统，这一点更加重要。

通常要安装到 SSD 上（类似 `/dev/sda`），如果是机械硬盘，则可能是 `/dev/hda`，NVMe 闪存则是 `/dev/nvme0n1`，最后的那个字符可能会变化，但大体上看起来差不多。

---

确定你的磁盘后，执行以下命令开始分区：

```bash
fdisk /dev/<YourDisk>
```

`<YourDisk>` 自然应该换成磁盘名字，以后这类替换我们不再赘述。

`fdisk` 随后会进入交互模式（就像 `iwctl`），现在来创建以下几个分区：

- 512 MB 的 EFI 启动分区

- 大约 4 GB 的交换分区

- 其余所有空间的主要分区

*实际上交换分区的大小可以自定，但不建议完全不设置（会增大内存压力），通常设置为内存大小和 4 GiB 中较小的那一个。此外，增大交换空间虽然不会拖累性能但毕竟会占用空间，如果拿不定注意，可以暂时不分配，稍后可以创建交换文件来解决这个问题。*

*另外特别提醒：如果你使用的是笔记本电脑，并且希望能够正常挂起（休眠），那么交换分区必须设置得更大，其大小应当是内存大小的 1.25 倍左右。*

EFI 启动区的分配则需要考虑更多：

- 如果你只安装一套操作系统，则必须分配。

- 如果先前计算机上已经存在 GNU/Linux 或类似操作系统，不必重新分配（如果你知道这个分区在哪里），可以直接使用。

- 如果先前计算机上安装着 Windows，则应当重新分配，因为 Windows 默认 EFI 分区可能不足以存储启动信息。

*高级用户可能会为 `/home` 或者 `/etc` 等创建单独的分区，这样以后当系统重新安装时，可以保留个人文件和设置，如果有兴趣可以尝试。*

---

确定目标后开始行动：

1. 如果你要**清除整个磁盘并安装**，则首先完成这个过程，否则请跳过这一步：
   
   1. 键入 `d`，删除分区。
   
   2. 如果有多个分区，`fdisk` 会询问要删除哪一个，键入 `1`。
   
   3. 重复以上过程，直到所有分区被删除。
   
   4. 键入 `g`，创建新的 GPT 分区表。

2. 键入 `n` 新建分区。

3. 询问分区号的时候，按回车默认，但要记住它。（空磁盘会是 `1`，已有分区的磁盘会更大）

4. 询问第一个扇区的时候，按回车默认。

5. 询问最后一个扇区的时候，键入 `+512M`，按回车确认。`fdisk` 就会为你创建一个 512 MB 大小的分区。

6. 键入 `t` 变更分区类型，通常会自动选择刚刚创建的分区，如果没有，键入刚刚记下的分区号。（现在也不要忘掉，等会会用到）

7. 键入 `1`，设定为「EFI 启动分区」（EFI System）。

8. 重复 2~7，再建立一个 4 GB（或者其它你喜欢的大小）的交换分区（`+4G`），不过这次要键入 `19` 设定为「交换分区」（Linux Swap，这个数字可以通过键入 `t` 再键入 `L` 来获得）。

9. 重复 2~7，再建立最后一个分区，输入大小时直接按回车，即默认选择剩余的全部空间。不需要更改分区类型（默认是 Linux 文件系统）。

10. **检查**，这很重要。键入 `p` 并仔细查看输出，检查分区是否正确。如果需要帮助，可以键入 `m`。

11. 确认无误后，键入 `w`，修改被写入磁盘。如果你觉得做错了，键入 `q` 放弃修改，然后再试一次。

*如果你真的很怕麻烦，不妨试试 `cfdisk`，它更加友好。不过对于有经验的用户，命令行会更快。*

### 挂载

> **挂载点**
> 
> 稍微介绍一下挂载点，这是 Linux 的一大特色机制。
> 
> 通常在 Windows 上，**磁盘是固定的，文件被存储在磁盘上**。这很符合我们的直观感受，没错吧？
> 
> 现在在 Linux 中，我们必须改变这一想法，也就是，**文件是固定的，磁盘为文件提供空间**。
> 
> 请花几分钟理解一下这个概念。
> 
> 在 Linux 中，所有的文件路径都从 `/` 开始，这也就是所说的根目录，`/` 下设有 `etc`、`bin`、`usr`、`home` 等多个文件夹，这些文件夹可以被（物理上）放在一个分区上，也可以每个拥有自己的分区，应用程序无需关心这些，只需要提供路径即可访问文件，而具体的组织方式是由 `fstab` 等组件完成的。
> 
> 举个简单的例子，如果将磁盘 A 挂载到 `/`，将磁盘 B 挂载到 `/home`，那么：
> 
> - 文件 `/usr/bin/bash` 将被存储在磁盘 A 的某个位置
> 
> - 文件 `/home/rarity/a.out` 将被存储在磁盘 B 的某个位置
> 
> - 如果移除（卸载）磁盘 B，`/home` 仍然存在，但会变为空文件夹（或者它原先的内容），此时如果向其中写入文件，数据将被存储至磁盘 A。
> 
> - 如果现在将磁盘 B 重新挂载到 `/home/ddd`，那么 `a.out` 的路径会变为：`/home/ddd/rarity/a.out`。
> 
> - 从磁盘 B 的角度来看就很明白：文件实质上始终是 `/rarity/a.out`，之所以路径发生了变化，是因为挂载点不同，路径的计算起点不一样。
> 
> 很快你就会发现这种方式比盘符简单灵活多了，因为很多命令可以无脑执行而根本不需要考虑盘符。

下面挂载磁盘，一个磁盘只有在被挂载后才能通过文件系统进行访问。

执行：

```bash
lsblk
```

找到你的磁盘（刚刚 `fdisk` 完成的），如果这么快就忘记了，可以根据容量判断。

接下来找到你的分区（EFI 启动区，交换分区，主分区），可以根据容量判断，也可以根据分区号识别。例如，`/dev/sdb` 上分区号为 `3` 的分区被记录为 `/dev/sdb3`。

*如果是 NVMe，则中间会多一个字母 `p`，例如 `nvme0n1p3` 而不是 `nvme0n13`，后者看上去就不对，请想想为什么。*

然后创建挂载点，因为挂载点本质上是目录，所以这样做：

```bash
mkdir /mnt
```

`mkdir` 用于创建目录。

*也许你会问，为什么需要这样一个 `/mnt` 呢？这其实就是很巧妙的地方：*

> **`/mnt` 是什么？**
> 
> 首先考虑我们现在在哪里，这是 Linux 中很重要的一个概念。
> 
> 现在我们位于 Arch 的安装盘中，也就是说，现在的 `/` 是你的 **USB** 磁盘，而并非日后操作系统将要运行的，计算机里面的那个磁盘。
> 
> 现在要做的是将几个分区挂载到 `/mnt` 和它的子目录，这样二者得到「对齐」，此后对 `/mnt` 内目录结构的修改，将被写入到计算机上的磁盘。
> 
> 下一次从硬盘启动的时候，Arch 会将**计算机上磁盘的根目录作为 `/`**，这样原来的 `/mnt/home` 现在就变为 `/home`。（想想上面刚刚介绍的原理，磁盘实际上只存储了 `/mnt` 里面的东西）
> 
> 看看，这就是 Linux 解决这种问题的巧妙方法。如果在 Windows 上想这样做，那是要费不少劲的。
> 
> 我们只需要把一个系统安装到 `/mnt` 里面，然后切换根磁盘，就可以使用这个系统！这个方式有点像把树的一根枝条剪下来插在土里又长成一棵新的树一样。只要理解了，就会发现十分方便，而且由于不涉及写入当前正在运行系统的磁盘，所以不会产生半路崩溃之类的问题。
> 
> 至于叫作 `/mnt` 并不是硬性要求，只是习惯上的命名。
> 
> *注：实际上 `/` 并不真的位于 USB 上，它应当位于 LiveCD 虚拟文件系统中，但为了便于理解，我们先这样表述。*

---

现在我们的分区还是「生的」，为了使用它，必须格式化分区：

```bash
mkfs.f2fs /dev/<MainPart>
```

这里的占位符请替换为**主分区**（除了 EFI 和交换的那一个）。此命令用于格式化分区为 F2FS 格式，如果你听说过 EXT4，并且想用，只需要换成 `mkfs.ext4` 就行了。当然，你还可以选择 `btrfs`、`xfs` 等，具体区别这里就不介绍了。

挂载：

```bash
mount /dev/<MainPart> /mnt
```

这样此分区就和 `/mnt` 绑定。

使用类似的方法挂载 EFI 分区（512 MB 大小的那个）：

```bash
mkfs.vfat -F32 /dev/<EFIPart>
mkdir /mnt/boot
mount /dev/<EFIPart> /mnt/boot
```

注意到这里实际上创建了 FAT32 文件系统，这是出于兼容性的考虑。

*之所以现在才 `mkdir` 是因为 `/mnt/boot` 位于 `/mnt` 的内部。如果在挂载 `/mnt` 之前就创建，挂载之后 `/mnt` 下的内容会被分区中的内容覆盖（隐藏），即使这个分区还是空的。因此，只能在挂载 `/mnt` 后创建 `/mnt/boot`。同时这样 `boot` 也被创建在磁盘（而非 USB）上。*

交换分区的创建有些不一样：

```bash
mkswap /dev/<SwapPart>
swapon /dev/<SwapPart>
```

整个过程一气呵成，但依然要注意不要输入错误的分区，否则当数据损毁后，你会十分沮丧。

现在来看看我们已经做了什么：

```bash
lsblk
```

观察输出，现在应该像是：

```
sdb                   disk
|-- sdb1    512.0M    part    /mnt/boot
|-- sdb2      4.0G    part    [SWAP]
|-- sdb3    114.5G    part    /mnt
```

分区的右边多出了挂载点标记。

如果一切都正确，那么我们可以继续，如果看上去不对，那就深吸一口气，然后检查哪里出了问题。

### 安装基本软件包

一个操作系统总是由很多软件构成的，因此并没有所谓的「操作系统安装过程」，本质上，就是要安装和配置一堆软件包而已（当然有点太多了）。

现在我们已经为新的 Arch 准备了空间，然而 `/mnt` 事实上还是空的，里面什么都没有，就此启动系统，肯定不成功。这也就是你手里的安装盘的作用之二（之一是启动系统）。所以，我们来安装 Arch 的基本软件包。

执行以下命令：

```bash
reflector --country <Country> --latest 5 --sort rate --save /etc/pacman.d/mirrorlist 
```

这个命令获取位于指定国家的五个最近更新的软件源服务器，且对它们进行按速率排序。至于什么是软件源，我们马上介绍。

`<Country>` 设置为你所在的国家就行了（只是举例，中国大陆为 `China`，法国为 `France`，当然要是你坚持写 `Antarctica`，也没有人拦着你）。存在空格的名字，须在两边加上引号，例如 `"United Kingdom"`，否则会引发错误。

这个命令的执行需要一分钟左右，所以请耐心等一下。

---

偶尔可能无法连接到 Arch 的软件源列表，你可能会看到 `error` 字样。这时只需要重试几次，通常就可以成功。

如果依然不行，那么执行：

```bash
rm /etc/pacman.d/mirrorlist
echo 'Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch' >> /etc/pacman.d/mirrorlist
```

也可以选择其它你喜欢的镜像服务器，只不过我个人测试认为 USTC 的镜像比较快。

`echo` 和 `>>` 的用法我们先保密，后面还会提到。

---

上一条命令完成后运行：

```bash
pacman -Syy
```

此命令更新软件源列表。

你可以把软件源想象成应用市场，但有一点点区别，因为应用市场是在需要时通过网络取得软件列表的，软件源则相反，软件列表被下载到电脑上，要用时直接查找就行了，所以在安装新的软件前，必须更新软件源以知道现在仓库中都提供哪些版本的软件。

更新密钥环：

```bash
pacman -Sy archlinux-keyring
```

这条命令更新 Arch 仓库维护者的密钥。

每个软件包在 Arch 上传时均经过签名确认完整性，`pacman` 会在下载软件后验证签名，确保文件没有被篡改（不是怕镜像站坑你，是为了避免在传输过程中出现的随机错误）。

更新这些密钥后，`pacman` 才能处理新的软件包。

> **包管理器与 `pacman`**
> 
> 你或许对包管理器不陌生，`npm`、`apt`、`nuget`、`pip`、`gem`、`yum`、`dnf`、`cargo`、`mvn` 等等都是各种各样的包管理器，这些里面几乎肯定有几个是你见过的。包管理器负责下载、安装、配置、卸载软件，解决依赖关系这样的工作。
> 
> 在 Windows 上你或许没有这样的感受，这是因为大多数软件都把它自己的依赖打包了起来，随软件一起附上，带来的唯一问题就是庞大的体积。
> 
> 在 GNU/Linux 上的软件都很小，而且你可以依赖仓库里任何你想要的软件包，包管理器确保你的软件在用户机器上具有合适的环境。
> 
> 这种机制不仅方便软件的更新，也节约了不少空间。想想你电脑里的数百个乃至数千个 `vcruntime114514.dll`，真是好可怕——当然，举个例子。
> 
> `pacman`~~（怕充满）~~是 Arch 的包管理器，负责从 Arch 官方仓库下载和安装软件包。你当然可以为你的 Arch 选配 `apt` 或者 `yum`，只要处理得当都没问题。但 `pacman` 是 Arch 官方使用的，出了问题虽然不包退换，却更容易得到帮助。

---

有些时候你在这一步可能会遇到错误：

```
ERROR: XXX could not be locally signed
```

仔细阅读计算机的输出，如果你遇到这个错误，那么你需要重启计算机：

```bash
reboot
```

重启之后依然要从 USB 启动，然后你需要**重新执行前面做过的所有操作**，除了分区（这实际上是之前做的最麻烦的一件事）。

通常重启之后问题就可以解决，但是如果没有，那么再执行以下操作：

```bash
rm -rf /etc/pacman.d/gnupg
pacman-key --init
pacman-key --populate archlinux
```

然后重新试试更新密钥环（`pacman -Sy archlinux-keyring`）。

你可能需要多重复几次以上步骤，但是如果你重复了很多次都没能解决，那么我们只能使用最后的绝招了：

```bash
echo "SigLevel = Never" >> /etc/pacman.conf
```

如果运行以上命令，那么你可以跳过密钥环的更新。

这会彻底禁止 `pacman` 的签名校验，允许你继续安装未签名的软件包，但是这样做**很不安全**，在操作系统安装完成后，一定要设法让 `pacman` 能够正常检查签名。

---

现在安装基本的软件包：

```bash
pacstrap /mnt base base-devel linux linux-firmware linux-headers nano
```

`base` 是 Arch 的核心部分，`base-devel` 是基本软件包组，`linux` 是内核，`linux-firmware` 是固件支持程序，`nano` 是文本编辑器，仅此而已。

如果主分区选择了 EXT4 文件系统，此处还必须安装 `e2fsprogs` 以支持它，简单将其添加在命令的最后面就行了。

`pacstrap` 能做一系列工作配置这些软件包（组），自然，使用 `pacman` 一个个来也是可以的，不过是会多一个损坏的键盘和一些折断的手指。

这个过程需要几分钟，你可以去玩一会你喜欢的游戏。

### 生成分区挂载表

还记得刚刚我们执行了一些 `mount` 命令吗？Arch 是不知道要如何挂载那几个分区的，因此，即使现在它们还处于挂载状态，但下一次启动时，它们并不会自动挂载，也就没办法进行读写。

我们必须对 `fstab` 进行设定，它位于 `/etc/fstab`，这个表告诉 Arch 如何挂载各分区。以往这个设定是很麻烦的，要查询各个分区的 UUID，然后设定合适的模式，不仅繁琐，还很容易出错。现在随着自动化的进展，这个过程可以自动完成：

```bash
genfstab -U -p /mnt >> /mnt/etc/fstab
```

它检测一些环境参数，然后生成合适的 `fstab`，要记住现在我们还是在 USB 中，并不是在真正的系统中（它在 `/mnt` 下），因此磁盘上的 `/etc/fstab` 对应着现在环境中的 `/mnt/etc/fstab`。

由于这个文件实在太重要了，因此我们确认一下它真的生成了：

```bash
cat /mnt/etc/fstab
```

虽然 ArchWiki 建议你检查其中的错误，但是其实如果真的有漏洞也很难看出来，你只需要注意 `swap`、`/`、`/boot` 等字样，如果它们出现了，那么基本上就没有问题。

`cat` 用于输出一个或多个文件内容。至于为什么不叫 `dog` 已经超出了我们的讨论范围，如果感兴趣可以自行搜索。

### 进入系统

接下来的所有操作都需要在实际的系统上完成，因为大多数软件希望系统位于 `/`，这样它们才能正常运行，但我们知道它现在位于 `/mnt`。如果现在从硬盘重启，系统确实就会位于 `/`，但是会有以下问题：

- 环境没有配置好，USB 提供的很多工具并不包含在刚刚安装的系统中（还记得吗，我们只是安装了 `base linux linux-firmware`）。

- 更要命的是，GRUB 引导文件没有生成，根本就无法启动。

所以我们需要有一个工具来模拟一个环境，使系统好像就位于 `/` 而不是 `/mnt`，这就是 `arch-chroot`：

```bash
arch-chroot /mnt
```

此命令一旦完成执行，终端就会发生变化，从此开始，`/mnt` 被映射到 `/`，你就「进入」了新安装的系统。当然这只是把根目录切换了一下，实际在运行的还是 USB 里面的那个 LiveCD 安装程序。

### 更新软件源和密钥环

为了避免一会儿忘记，我们现在更新 `pacman` 的软件源和密钥环：

```bash
pacman -Syy
pacman -Sy archlinux-keyring
```

之所以还要更新一次，是因为之前那一次更新只更新了 LiveCD 的软件源和密钥环，这一次是更新实际操作系统中的那一份。

*`reflector` 不需要重新执行，因为安装时已经自动为你复制好了。*

### 校正时间

使用 `ln` 命令设定时区：

```bash
ln -sf /usr/share/zoneinfo/<Region>/<City> /etc/localtime
```

如果你在中国大陆，`<Region>` 就是 `Asia`，`<City>` 就是 `Shanghai`。

*`ln` 的实际作用其实是创建文件链接（不是 URL，那是超链接），有点像快捷方式，在这里它把 `/etc/localtime` 指向 `/usr/share/zoneinfo/<Region>/<City>`，从应用程序层面而言，这两个文件的内容（看上去）会始终保持一致。此外，文件链接比复制要节省空间，而且可以连接两个动态变化的文件。* 

---

如果你想要知道所有可能的时区，可以这样做：

```bash
ls /usr/share/zoneinfo/<Region>
```

这会列出所有可能的地区（大洲）。

```bash
ls /usr/share/zoneinfo/Asia
```

这会列出亚洲所有可能的时区设置。只需要选择和自己在同一时区的城市即可，因为它只用来设置时间。

`ls` 用于列出某个目录下的所有子目录（子文件夹）。

### 本地化

为了能够设置操作系统的语言，我们需要进行本地化过程。

编辑文件：

```bash
nano /etc/locale.gen
```

你将进入 `nano` 的文件编辑界面，使用上下键移动视图，找到这样两行（并不是挨在一起的）：

```
#en_US.UTF-8 UTF-8
#zh_CN.UTF-8 UTF-8
```

删除它们之前的 `#` 符号，然后按 `Ctrl + X`，`nano` 会询问是否要保存，键入 `y` 并回车确认。

如果你打开时文件为空，那么一定是哪里弄错了。退出 `nano`（不要保存），重新输入正确的命令。

---

现在运行：

```bash
locale-gen
```

这个程序会生成必要的本地化文件。

运行完成后，编辑文件：

```bash
nano /etc/locale.conf
```

和之前那一条很像，但并不相同，请注意准确地拼写。这个文件不存在，所以打开时应当为空。

向其中写入以下内容，然后保存：

```
LANG=en_US.UTF-8
```

设置为英文是有道理的，因为这是用于系统级的本地化，考虑到控制台（TTY）其实很难处理非 ASCII 字符。如果将来系统出了问题，我们还得回到控制台，这时如果输出全是乱码，你会有被蟒蛇缠住的感觉。

### 网络设置

现在来设置主机名：

```bash
echo '<ComputerName>' >> /etc/hostname
```

`echo` 和 `>>` 配合使用用于直接将 `echo` 后面的内容写入文件，而不需要去打开编辑器，很快你会发现这很实用。

> **巧妙的命令组合**
> 
> 为什么没有类似 `write-file a.txt "hello, world"` 这样的命令？
> 
> 这是因为使用已有的命令组合（在这里是 `echo` 和重定向）足以简单地完成这些任务，而且还可以提供极高的自定义过程。
> 
> 想想下面这两个问题：如果我想同时写入两个甚至八个文件怎么办？如果同时还想做些筛选怎么办？这就得设计很多很多的命令！
> 
> 这样做会带来两个问题：
> 
> - 系统执行命令的速度会变慢（因为要查找命令）。
> 
> - `write-8-files-and-search` 这样的命令会让人不禁担忧设计这种命令的人是否已经疯了。
> 
> 你可以试着搜索一下 `tee` 和 `grep`，看看如何使用它们的组合解决这些问题。
> 
> GNU 所编写的程序（当然还有很多其它程序）都遵循「单一功能原则」：一个程序只负责一个任务，例如 `cat` 只负责读文件，而 `grep` 只负责查找——虽然它的查找功能十分强大，但也只是查找。
> 
> 通常我们称这种程序为「工具」（Tools），而称那些有很多功能的程序（例如 GIMP）为「应用」（Applications）。

引号 `''` 有时是可选的，但是为了不出现意外，还是加上吧。

`>>` 是重定向标识，`echo` 的默认输出是 `stdout`（标准输出），为了将其写入文件需要将输出流「接到」文件上。

计算机名不应当包含空格。此外，虽然没有严格限制，但出于兼容性的考虑，请还是尽量只使用 ASCII 字符。

---

接下来绑定本地回环端口，如果不知道这是什么也不要紧，因为对于大多数情况，这个设置都是固定的。

```bash
nano /etc/hosts
```

这个文件可能已经存在，也可能为空。不管怎样，向其中填写以下内容并保存：

```
127.0.0.1 localhost
::1 localhost
127.0.1.1 <ComputerName>.localdomain <ComputerName>
```

`<ComputerName>` 应该替换为上一步所选择的计算机名。因为这是在编辑文件，我们怕你忘记了。

*注意最后一行开头是 `127.0.1.1`（不是 `127.0.0.1`）。虽然它并没有任何特殊的地方，但不知为何，很多人把这个数字填错。就像「管理员」和「管埋员」一样。*

### 创建帐户

操作系统必须有帐户才能访问。历史上的一台电脑都是好多人公用的（即使现在也是），由于 PC 的普及，很多计算机上只有一个帐户，但不管怎么样，现在我们的系统什么也没有，所以需要创建帐户。

首先运行以下命令：

```bash
passwd
```

这用于设置 `root` 的密码。`root` 是绝大多数 GNU/Linux 上的最高权限帐户，拥有控制系统一切的权力，因此该密码请勿设置得太简单（但是也不要胡乱输入，如果忘记会很麻烦）。

输入密码没有回显，确保输入正确后回车即可。（退格键依然可以使用）

---

现在来创建和设定个人帐户。（不能什么事都以 `root` 身份完成，否则如果你运行了一个恶意软件，它将可以删除计算机上的所有内容，还能任意解码你的密码，这太可怕了！）

```bash
useradd -m -G wheel -s /bin/bash <UserName>
```

用户名可以自选，但是依然要使用 ASCII 字符，并且不能有空格。此外如果使用字母，只有小写字母可以被接受。

设定密码：

```bash
passwd <UserName>
```

这和设定 `root` 的方法是一样的，不过由于需要经常使用，建议设置得简单好记（但不可以少于 6 个字符）。

---

个人帐户是没有控制系统目录的权限的，当然可以通过登录到 `root` 来做这些操作，但是这样会带来两个问题：

- `root` 的密码太长，登录很麻烦。

- 这让问题又回到原点。

所以我们要使用 `sudo`，它允许被授权的普通用户使用 `sudo` 命令来临时获取管理员权限。刚刚所创建的新用户并不在这里，所以我们需要告诉 `sudo`。

```bash
nano /etc/sudoers
```

找到如下一行（或者类似的）：

```bash
# %wheel ALL=(ALL:ALL) ALL
```

*类似这样的行在此文件中共有三行，它们靠得比较近，请确保你选择的是第一个（第四个 `ALL` 后不应当再有任何后缀）。*

去掉最前面的 `#` 和空格，然后保存并退出。

### 安装微码

微码控制处理器的指令解释，有时也用来修正硬件错误。既然是 CPU 级别的，那么怎么想也都应该安装上。

运行下面两条命令中合适的一条：

```bash
pacman -S amd-ucode # AMD
pacman -S intel-ucode # Intel
```

`#` 后面的是注释，是给你看的，不用输入终端。

两条命令只需执行一条，根据你机器搭载的 CPU 选择即可。

### 安装网络组件

现在安装网络组件：

```bash
pacman -S networkmanager
```

### 启动引导

在继续之前我们要说明一点额外的东西，当然，这对于后续步骤暂时没有影响，如果着急，可以先跳过。

> **还需要启动引导程序吗？**
> 
> 你可能听说过 GRUB 这个名字，它是大多数 GNU/Linux 发行版的默认启动引导程序，GRUB 异常的强大，可以引导几乎所有的操作系统内核。
> 
> 但是，进入 UEFI 时代后，我们其实多了一种选择：**直接生成 Linux 内核的 EFI 启动文件并交由 EFI 引导**（不应当称之为 BIOS，因为 EFI 和 BIOS 并不一样）。这会使得启动略快一些。不过这是相当麻烦的，因为要手动（或者设置自动程序）生成内核的引导文件。如果启用了安全启动，还要进行内核签名。
> 
> 以上问题当然是有解决方案的，但这已经超出了本指南的范围，我们会在其它文章中再行介绍。另外，使用 EFI 直接引导时不方便选择启动系统（需要进入 EFI 菜单），所以只建议单系统用户使用。
> 
> 不管怎样，让我们先安装 GRUB 吧，因为下一次重启就需要引导。除非你打算在这里完成 EFI 的配置，但如果你真的做了，你会有被重物压住胸口的感觉。

如果在安装双系统，请先执行以下命令：

```bash
pacman -S os-prober
```

这个程序可以识别其它的操作系统。

现在安装 GRUB 软件包：

```bash
pacman -S grub efibootmgr
```

然后告诉 GRUB 生成文件到指定的 EFI 分区：

```bash
grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub --recheck
```

命令很长，但依然要准确地输入。如果哪里不正确，GRUB 会提醒你。

---

现在要让 `grub` 启用 `os-prober`：

```bash
nano /etc/default/grub
```

找到如下一行：

```
#GRUB_DISABLE_OS_PROBER=false
```

将 `#` 移除，然后保存文件。

---

现在运行以下命令：

```bash
grub-mkconfig -o /boot/grub/grub.cfg
```

此命令生成供 GRUB 读取的配置文件，用于启动。

在输出中你应当看到 `vmlinuz-linux`、`initramfs-linux` 等字样，并且要确保最后 GRUB 输出了 `done`。

如果缺少了哪一个，或者看上去有问题，那么请再试一试，如果依然不行，那么……如果你愿意，可以键入 `exit` 返回 LiveCD，再键入 `reboot` 重启，之后你可以从头再来（当然，不必重新分区了）。

取决于设置，Windows 可能并不会出现，这是正常的，重启之后你会有机会重新生成引导。

### 安装桌面

> **使用桌面环境还是窗口管理器？**
> 
> 要回答这个问题，首先必须明确二者的区别。
> 
> 桌面环境（DE）是窗口管理器（WM）的超集。DE 提供菜单栏，托盘，标题栏，小工具等多种组件集合，用上去很像其它操作系统的「桌面」。而 WM 通常只提供简单的窗口管理（包括层叠），操作主要依赖键盘。因为由于不涉及图形系统，很多 BUG 就不会产生。
> 
> 本指南使用 DE，因为我们要创建的是桌面操作系统，所以应当尽可能给它「桌面」的感受，同时也不会给人太高的学习成本。但如果喜欢 WM，我们的其它文章中也会提到如何配置和安装。
> 
> 如何在二者中做出选择本来就是一个比较的问题，但是有的时候或许我们并不需要选择，既然你已走上 Arch 这条路，或许有一天你能找出一个不错的解决方案。
> 
> 谁知道呢？

为 GNU/Linux 添加桌面本身就是安装几个应用程序的工作，所以这件事情并不困难。不过从这里开始是一个分界点，从此之后的很多软件并不是只有一种选择，我会尽可能列出多的可能，试图阐明它们的区别，不过最终的选择权依然在你的手中。

#### 图形系统

下面来面对这样一个问题：图形系统。它用于管理图像的显示。

*我们希望尽可能将问题简单化，因此并未区分显示协议、窗口系统、显示协议实现等概念，而是统称图形系统。*

目前，主流的选择有两个：

- X Window System（X11），这个系统比较古老，这既是优势也是缺陷：
  
  - 支持面非常广泛（几乎所有）。
  
  - 运行稳定，BUG 较少。
  
  - 系统占用相当高（如果在玩 Minecraft 时运行 `top`，`Xorg` 经常紧挨在 `java` 的下面），运行比较慢。
    
    *在一些比较早期的文章中，X 被评价为「较慢」，但一段时间以来，各种实例都表明，X 的性能消耗已经远远不再是「较高」。在渲染程序越来越复杂的今天，X 的性能问题明显地暴露出来。*
  
  - 不太安全（类似 AutoHotKey 之类的东西是有可能存在的）。
  
  - 完全不兼容 Wayland，Wayland 程序不能在 X 上运行（除非使用 `weston` 混成器，但这样有为了使用 X 而使用 X 的嫌疑）。
  
  - 对高分辨率和高刷新率的屏幕支持较差，可能存在驱动问题。
  
  - 可供参考的资料比较多。

- Wayland，这个系统比较新，设计上是为了取代 X——它的优势正是 X 的缺陷，反之亦然：
  
  - 支持面比较窄（虽然仍然在快速增加）。
  
  - 运行不太稳定，BUG 较多。
  
  - 对于新设备的支持可能比较好（相当多的设备还没有得到支持，但可以预见，如果它们得到支持，将可以很好地运行）。
  
  - 系统占用较低（我们很难指望这么频繁使用的组件拥有极低的占用），运行很快。
  
  - 比较安全（如果未经许可，屏幕录制是不可能的）。
  
  - 大多数 X 应用程序可以在 Wayland 上运行（如果合理使用 `xwayland` 等兼容程序）。
  
  - 可供参考的资料比较少。

*过去的很多文章中认为 Wayland 缺乏驱动程序，在当时的确如此，但这一现象现在已有所改善：NVIDIA 495 驱动已经提供了相应的支持，而 Nouveau 也基本上到位了（至少已经有成功的例子）。*

---

你可能在想「我全都要」。噢不，你不能。即使你设法安装了两套图形系统，你也只能使用一个。所以……

> 做出你的选择，并承担相应的后果。

现在我们回来，希望你已经做出了自己满意的回答。

*不必为选择 X 而担心更新问题。影响如此巨大的图形系统更新时，一定会有成熟的解决方案。而且，并没有人规定你必须升级，这可不是 Windows Update！另外，即使 X 的性能的确不好，但还是比 Windows 强多了，你大可不必担心。*

*也不必为选择 Wayland 而担心 BUG。尽管漏洞随时都存在，但是它们通常有合适的修复方案。即使不兼容，大多数情况下也可以通过将应用程序切换到 XWayland 上完成运行，而要是兼容，那就是赚了！*

---

如果决定使用 X：

```bash
pacman -S xorg
```

如果决定使用 Wayland：

```bash
pacman -S wayland wayland-protocols xorg-xwayland
```

#### 桌面环境

现在你可以选择一个喜欢的桌面环境。

KDE 还是 GNOME？噢不，这个看法也太狭隘了，来看看 ArchWiki 给出的一些选择（部分没有列出，排名按字母顺序）：

- Cinnamon

- Cutefish

- Enlightenment

- GNOME

- KDE

- LXDE

- Sugar

- Xfce

- Trinity

……这只是一小部分。

到这里的选择就很多了，我们不太可能在这里一一介绍。不过你可以前往 ArchWiki 并搜索名字（当然是英文）来进入其页面，并找到相应的安装方法和配置方法。

同时你还需要为桌面环境选配一个显示管理器（Display Manager），常用的选择有很多，例如 GDM、LightDM、SDDM 等。

在选择时要遵循一个原则：**先成套后搭配**，也就是说，如果桌面环境为你提供 DM，就使用它提供的（例如 GNOME 搭配 GDM），否则再自行搭配（例如 Cinnamon 搭配 LightDM）。如果不这样做，一些桌面环境提供的功能可能并不能用（如 GNOME 的休眠）。你同样可以在 ArchWiki 上找到一些建议。

*当然如果你认为你的水平足够高，那么这些限制都可以随便打破，只要你知道遇到错误怎么处理。*

最后你要运行的命令可能是像这样：

```bash
pacman -S <DEAndDM>
systemctl enable <DM>
```

无论选配哪一个 DE、哪一个 DM，都要记得运行 `systemctl enable <DM>` 来启动此 DM 的服务，否则将无法进入登录界面。

顺便提一句，GNOME 已经正式支持 Wayland，所以若要让 GNOME 在 X 上运行，需要额外的配置：

```bash
nano /etc/gdm/custom.conf
```

找到这一行：

```
#WaylandEnable=false
```

删除 `#`，然后保存。

### 重启

我们很想一鼓作气，但是……

> 你有没有听见风扇的悲鸣？
> 
> 你有没有感受到处理器在分崩离析？
> 
> 你不曾注意 USB 早已变得滚烫……

好啦，开个玩笑，不过现在的确要重启一下了。正好也借此机会，我们来确认一下 GRUB 能否正常运行，同时看看我们已经做了多少。

执行：

```bash
exit
```

退出当前系统（还记得 `arch-chroot` 吗）。

再执行：

```bash
shutdown now
```

来关闭计算机。

等指示灯熄灭，所有的部件都冷却下来后，拔下 USB，然后再接通电源开机。

*理论表明，直接 `reboot` 有极小概率引发硬件故障。由于我们刚刚完成安装，最好关闭电源，让硬件彻底复位一次再运行。*

---

开机时依然要设法进入 UEFI 设置，然后调整启动顺序，将 Arch Linux 或者 GRUB 作为第一启动项。

有时它可能不叫这个名字，没有关系，只要确保将「Windows Boot Manager」放在最后，一般 Arch 也就相应地放在最前面了。

现在等待系统启动（通常几秒钟），随后你会看到图形化的登录界面，输入你的密码并登录即可。

现在打开虚拟终端，如果之前没有生成 Windows 的引导文件（你在 GRUB 菜单里没有看到 Windows），现在执行：

```bash
sudo grub-mkconfig -o /etc/grub/grub.cfg
```

希望这次所有的引导文件都正常生成。 

### 驱动程序

现在我们已经来到最后一步，也就是驱动程序的安装。

大多数驱动程序已经内置在操作系统中，包括 `nouveau`、`mesa`、`amdgpu` 等。对于我们所使用的机器，并不需要安装任何额外的驱动，所有的组件都可以正常运行。我们无法预知你的机器上可能出现的问题，不过以下提供针对硬件的一些建议：

- NVIDIA GPU：
  
  - 如果是唯一的图形卡，并且你的屏幕分辨率高（4K 及以上），那么 `nouveau`（内置的自由驱动程序）最高只能支持 30 Hz 的刷新率。
    
    我们不建议使用非自由软件，所以根据你自己的意愿，如果的确问题影响到正常使用，你可以使用 `nvidia` 这一专有驱动程序……但希望不需要。
    
    `nouveau` 已经内置，但如果你不得不使用专有驱动，可以运行以下命令：
    
    ```bash
    sudo pacman -S nvidia
    ```
    
    如果你的内核是定制的（有这种情况），那么不要使用以上命令，使用：
    
    ```bash
    sudo pacman -S dkms
    sudo pacman -S nvidia-dkms
    ```
  
  - 较新的图形卡使用 `nouveau` 就可以正常支持 Wayland，如果不能，那么和上面的解决方法一样。
  
  - 如果使用双图形卡，这会有点麻烦，因为涉及切换的问题，我们会在其它文章中再行介绍。
  
  - 太老的图形卡可能不被支持，并且无法正常运行 Wayland。

- AMD GPU：
  
  - `mesa` 和 `amdgpu` 已经内置，它们应当可以驱动绝大多数现在流行的 AMD 图形卡。如果在使用 X，并且有必要的话，也可以选择安装另一个驱动（通常也应该内置）：
    
    ```bash
    sudo pacman -S xf86-video-amdgpu # X11
    ```
  
  - 更老的图形卡需要 ATI 驱动程序，可参考 ArchWiki 完成安装。

- Intel GPU：
  
  - 无需单独驱动，系统已经内置一套 Intel 图形卡驱动程序。

- 蓝牙：
  
  - 通常安装 `bluez` 和 `bluez-utils` 可以解决蓝牙驱动问题：
    
    ```bash
    sudo pacman -S bluez bluez-utils
    ```
    
    如果蓝牙没有自动激活，运行以下命令：
    
    ```bash
    sudo systemctl enable bluetooth
    sudo systemctl start bluetooth
    ```
  
  - 有些桌面环境集成了蓝牙控制器，如果这样则无需单独安装。
    
    如果没有，那么可以使用 `bluetoothctl` 这样一个小巧的命令行控制器。
  
  - 如果蓝牙看上去还是不正常，那么你需要将你自己加入 `lp` 用户组：
    
    ```bash
    sudo usermod -aG lp -s /bin/bash <UserName>
    ```

- 触摸板
  
  - 无需单独驱动，`libinput` 足以处理大多数情况。
    
    *笔者曾经认为触摸板轻触以单击不管用是驱动问题，直到我发现了 GNOME 设置里的「轻触以单击」选项……*

- 声卡
  
  - 声卡这一装置已经如此流行，以至于甚至没有人注意到它还有驱动程序。从未有哪个外部设备如声卡一般如此统一和协调：无需驱动程序，它几乎肯定能用。

- 鼠标和键盘
  
  - 作为 PIC 上的设备（PIC 1 和 PIC 12），鼠标和键盘通常无需驱动。

- 打印机
  
  - 这有点复杂，基本上是要取决于打印机制造商对 OpenPrinting 的支持程度，不过下述几个步骤通常适用于大多数打印机。
  
  - 如果制造商提供了 GNU/Linux 的驱动程序，建议使用它。
  
  - 否则，试试 `cups` 与 `gutenprint`。
  
  - 如果这还不行，试着找到与你的机器最接近的驱动程序并使用。
  
  - 如果以上方法都不行，那么很遗憾，这台设备或许无法被驱动。

- 摄像头
  
  - 通常无需单独安装驱动程序。如果它无法正常运转，请查阅 Wiki 上是否有对应机型的解决方案，或者联系其制造商。

- 数位板
  
  - 这也有点复杂，主要取决于制造商。
  
  - Wacom 的数位板已经得到 GNOME（和许多其它 DE）的支持。
  
  - Huion 的数位板及衍生产品可以在少量修改设备信息的情况下进行驱动，参见 [digimend-kernel-drivers](https://github.com/DIGImend/digimend-kernel-drivers)。
  
  - 对于其它制造商的产品，你可能需要额外的帮助。
    
    *既然有硬件，就应当有方法使用。若此路不通，将它打通便是。*

### 完成

重启计算机，如果一切正常，GRUB 将可以引导 Arch Linux。如果在安装双系统，你会发现 Windows 也应该出现在 GRUB 选项中。（当然，要是没准备好安全启动，还是先不要动它）

## 接下来做什么

### 美化

系统启动后一定会令你大吃一惊，因为默认的 GNOME 其实一点都不简陋，即使不安装主题，它也相当的优雅。

当然，即使你没有使用 GNOME，其它的 DE 一定也为你提供了不错的体验，如果没有，请告诉他们，我相信大多数开发者会对于改善用户体验很有兴趣。

如果你不喜欢默认的主题，那也没有关系，你可以在网络上搜索一些适合你的 DE 的主题，然后安装它，这些纯粹是个性化的东西，因此就不展开了。

此外，GRUB 也是可以设定主题的，所以你知道要做什么了不？（大多数人都同意黑底白字绝对不是最好的设计）

DM 也是可以设置主题的，不过相比桌面本身而言，可选的略微少了一些。当然，你可以设置自动登录来直接跳过登录过程，权限系统会保证操作系统的重要文件不受破坏。但是如果需要绝对的安全，还是不要这样做。

声音什么的也是可调的，如果你之前不知道的话。

### 安全启动

**这并不是只有双系统才应当考虑的问题。**

UEFI 新增的功能之一是安全启动，它保证所引导的内核已经过签名，这样可避免恶意软件侵入内核破坏操作系统。虽然大多数主板上内置 Microsoft 的 CA 证书，但其实这是可以修改的。

绝大多数情况下，GNU/Linux 自身的安全已经足够，但是安全启动仍然应当被启用，如果没有安装 Windows，那么只需要一些不很复杂的配置，就可以在 `pacman` 每次升级内核时自动签名，而同时这也能保证你的安全。

而如果要和 Windows 并存，问题也并不复杂，不过详细的操作方法已经超出我们的范围，所以只好以后有机会再说了。

虽然说得挺吓人，但也不必太过慌张，你认为有多少恶意软件可以完美地注入到一个常常更新的内核中呢？所以你大可以直接删除 Windows，然后完全无视这个功能。以前没有安全启动的时候，我们碰到过这些问题吗？所以说，很多这样的问题，其实都是被「制造」出来的。

> 如果用自己数年糟糕的使用体验去换一次防御病毒入侵的机会，那这种防御到底有什么意义？

### 安装输入法

如果要使用其它语言输入，应当安装输入法。对于中文（以及一些其它的语言），`fcitx-im` 和 `ibus` 等等都是不错的选择。注意在 Windows 上很流行的输入法通常在 GNU/Linux 上并不一定工作得很完美。

### AUR

AUR 是由社区维护的软件仓库，其中包含一些 `pacman` 不提供的。

由于 AUR 需要从源构建软件包，因此一个「流畅的」网络是必需的。

AUR 的使用如下（以安装 `unicorn` 为例）：

首先安装 `git`：

```bash
sudo pacman -S git
```

然后执行：

```bash
git clone https://aur.archlinux.org/unicorn.git
cd unicorn
makepkg -si
```

这三步流程就是 AUR 的使用方法，注意，到这里我们并没有使用任何辅助工具，一切都只是简单的下载代码并且执行构建和安装的过程。

当然你可能会卡在其中的某一步，因为 AUR 的构建过程可能需要从 `PKGBUILD` 指定的地方下载并签出源代码，然后执行编译等过程。如果它的代码很少，那么等一等就可以了，而如果是像 `linux-git` 这种大型项目……那么你应该知道要有一个「流畅的」网络的原因了。

正常的 AUR 用户都不会喜欢手动输入这些命令，所以 AUR 助理就诞生了。曾经 Yogurt 是最好的 AUR 助理之一，但现在它不再维护了，在 Arch 这样的滚动发行版中，不再维护就基本上等于退出舞台，我们需要替代品。

如同 DE 一样，AUR 助理的选择也有很多，我们并不在这里推荐任何一款，因此，你可以到 ArchWiki 上去寻找一个你喜欢的（并且还在维护的）。

### 更新系统

也就是俗称的「滚」，它是指这条命令：

```bash
pacman -Syu
```

它更新系统中的所有软件包，确保它们处于最新。

这条命令需要频繁执行（几乎每天），因此你可能会希望给它安排一个系统服务来自动化这个过程。

如果执行过程中出了错误（滚挂）也不要惊慌，因为世界上所有的 Arch 用户也会面临和你一样的问题。同理，开发者一定会在自己的电脑上测试后再发布，而测试环境绝大多数情况下和你的环境应该是几乎一样的。

最常见的错误是内核更新，同时显卡驱动没能跟上内核而造成的黑屏现象。因此，在快乐地 `Syu` 时也请注意 Linux 内核的更新，并重新编译（DKMS 会为你自动完成）或者更新驱动。

另一个解决此问题的方法是始终保留一个可用的内核，但由于 Arch 不支持部分更新，这可能有点困难，不过依然是可以办到的，方法之一就是同时安装 `linux` 和 `linux-lts`。

*这也是我们不建议添加大量的其它软件源的原因（一个经典的反例是 Ubuntu 的 PPA）。使用统一的标准和规范，在出问题时更容易得到更多的帮助。当然这只是建议，请按自己的需求做最后决定。*

### Wine

[Wine](https://www.winehq.org/) 是一个可以在 GNU/Linux 上执行一些 Windows 应用程序的组件，它通过翻译 API 来完成这个过程。由于 Microsoft 并未公开一些方法的规范，因此 Wine 只能依靠猜测，所以会使得它不太稳定。但是，相当多的软件其实已经可以使用 Wine 来运行（.NET 3.5 和 4.6.1 可以「完美」运行，想想基于它创建的应用程序有多少）。

如果你已经下定决心删除了 Windows，却又对 Windows 的一些应用程序念念不忘，或许 Wine 能够帮你渡过一段难关。

你可能会认为我把一个 Windows 相关的问题放在这里不太合适，但是其实并不是如此。如果 Wine 是一个自由软件，而 GNU/Linux 也是，那么为什么这个组合就不能使用呢？至少这为更多努力在改变的人带来了希望啊。

### 游戏

Unreal Engine 和 Unity 都支持 GNU/Linux，类似这样的通用游戏引擎还有很多。游戏公司如果愿意，可以提供针对 GNU/Linux 的发行版本（有些的确也是这么做的，例如 Dota 2 和 Minecraft）。

Steam 上也有相当多的游戏可以在 GNU/Linux 上运行（约 70%），它们中有相当一部分虽然不原生支持，但可以通过转译等操作来运行，例如 Apex Legends、Warframe 和 Grand Theft Auto V。

现在你还觉得 GNU/Linux 不适合游戏吗？其实一开始就不是这样。在 GNU/Linux 上，Minecraft 平均比 Windows 运行时帧率高约 50%，如果不信可以自己试试。

对于移动设备上的游戏那就更加简单，因为模拟器实在是太多了。当然，不使用模拟器的方法也是有的，这里就不展开介绍了。

另外，还有多少人不知道 Android 经过修改也可以直接安装在电脑上？

### 开始你的创造

> 一切到此结束，一切又由此而始……

至此，我们的这份指南的主体部分就结束了，但这只是开始，现在你拥有了一套 Arch。也许它不完美，也许它不成熟，都不要紧。尽管整个过程费时费力，但是如果现在让你说说你的 Arch 上面有些什么，你是不是该了如指掌了？

更重要的是，这一切是由你来指挥的，**计算机已经在你的掌控之中**！再想想捆绑安装的各种电脑管家，最多只能推迟 35 天的强制更新，没来由的各种弹窗，预装的成组软件……这样自己组装而来的系统，是不是有一种舒畅感？

## FAQ

这里只包含非技术性问题。

> XXX 并不是这样运行的，它应该是这样的！

你知道更多的专业知识，这说明你很强大。但指南的编写并不是要提供完全正确的信息，而应当是有用的信息。

在安装 Arch 的过程中，我们需要知道的不是「Microcode 的诞生并不是为了修复 CPU 错误而是为了提升性能」这样的信息，而是 `pacman -S amd-ucode`。因此，请容忍一定量的错误，如果正义感实在很强烈，那就用用 F12 吧。

> 安装 Arch 如此麻烦，我还不如用 XXX 呢。

Arch 除了自由，另一个很重要的特性是「各取所需」。使用 `nouveau` 完成 PRIME Offload 显然并不是很现实。因此，在我们为 `nouveau` 提交代码的时候，我们仍然可以使用 `nvidia`，正如 GNU 项目最早是在 UNIX 上开始开发的一样。

自然，每个发行版都有其特点，但这是 Arch 安装指南，不是 GNU/Linux 安装指南，我无权在 Arch 的文章里推荐其它的发行版。如果你需要更多的理由，这可以算一个。

> 我的硬件比较特别，使用这种方式安装失败了。

绝大多数问题出现在显卡，而因为显卡太老连控制台都无法显示的情况现在已经几乎不存在。因此，只要你还可以进入控制台，你就可以操作 `pacman` 来安装合适的驱动程序。唯一的失败是硬件烧毁，在此之前，不存在失败之说。

本指南足够让大多数计算机成功进入操作系统桌面，但若要进一步优化（例如键盘灯），则需要更多的配置。市面上的机型很多，而且每个型号都不完全相同，要找出每一种的配置方法是一个十分艰辛的过程，许多逆向工程师和硬件工程师已经加入，也许你也可以试试。

> 我在我的 Mac 上试了，但是没有成功。

Mac 的硬件很特殊，失败也是常有的事，且 Mac 安装 Arch 的需求实在太低，本指南就不予叙述了。不过，你仍然可以从网络获得额外的帮助。

## 结语

> 我本可以忍受黑暗，如果我不曾见过光明。

再一次回头看我们最初的目标，一路走来并不容易，现在你坐在新拆封的桌面环境之前，想想之前的终端，是不是有一种冲出黑暗的感觉？如果是的，那么恭喜，欢迎你通过入职考核，正式成为 Arch 的一员！

最后，让我们用一条有趣的命令结束这份指南……

打开虚拟终端，它现在应该在应用列表里（如果 DE 已经集成）。不过要是没有，你可以按 `Ctrl + Alt + F1` 进入（熟悉的）TTY 终端，如果不行，再同时按下 `Fn`。

键入（不要忘了切换到英文输入法）：

```bash
s='s=\47%s\47;printf "$s" "$s"';printf "$s" "$s"
```

（你可以多试试几次，没有危险！）

它输出了些什么？你能再写出一个类似的程序吗？

（要回到图形界面，按下 `Ctrl + Alt + F7`，如果不行，再同时按下 `Fn`）

GNU/Linux 的世界远远比想象得要广阔和奇妙得多，一切皆有可能。

> 这是属于你的世界，我很荣幸为你敲开它的大门。

现在该说再见了！
